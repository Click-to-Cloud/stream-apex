{"title":"Stream.apex","githubRepo":"Click-to-Cloud/Stream.apex","googleAnalytics":"","index":{"title":"Home","description":"Stream.apex is a library that streamlines your Funcs in Apex.","content":" Fluent API Stream.apex has a fluent API to manage stream operations. Multicast Stream.apex has unicasting streams and multicasting subjects. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/stream-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/stream-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/stream-apex/docs/search.html"},"Methods":{"children":{"creation":{"title":"Creation Methods","description":"Creation Methods","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} create Create from stream source Stream.create(new CustomSource()) .subscribe(R.debug); of Create from value Stream.of('abc') .subscribe(R.debug); // abc throwError Create from error Stream.throwError('test error') .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // (Error: , test error) empty Create an empty stream Stream.empty() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // Completed never Create a stream that does not emit error or complete event. Stream.never() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); fromData Create a stream from a collection Stream.fromData(new List{ 1, 2, 3 }) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed with Create a stream from values Stream.with(1) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // Completed | Method | Description | | ------ | ----------- | | with(Object) | Create a stream from one value | | with(Object, Object) | Create a stream from two values | | with(Object, Object, Object) | Create a stream from three values | range Create a stream from ranges of values Stream.range(1, 3) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed generate Generate a stream with the Funcs Stream.generate(1, R.lt.apply(R.placeholder, 4), R.inc) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed concat Create a stream by concatenating other streams Stream.concat(new List{ Stream.of(1), Stream.of(2), Stream.of(3) }) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed | Method | Description | | ------ | ----------- | | concat(Stream) | Concat one stream | | concat(Stream, Stream) | Concat two streams | | concat(Stream, Stream, Stream) | Concat three streams | ","srcFilePath":"src/pages/docs/Methods/creation.md","id":"creation","location":"/docs/Methods/creation.html","url":"/stream-apex/docs/Methods/creation.html"},"funcs":{"title":"Functions","description":"Functions","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} create Create from stream source Stream s = (Stream)Stream.Funcs.create.run(new CustomSource()); ofData Create from value Stream s = (Stream)Stream.Funcs.ofData.run('abc'); throwError Create from error Stream s = (Stream)Stream.Funcs.throwError.run('error'); empty Create an empty stream Stream s = (Stream)Stream.Funcs.empty.run(); never Create a stream that does not emit error or complete event. Stream s = (Stream)Stream.Funcs.never.run(); fromData Create a stream from a collection Stream s = (Stream)Stream.Funcs.fromData.run(new List{ 1, 2, 3 }); with Create a stream from values Stream s = (Stream)Stream.Funcs.with.run(1, 2, 3); range Create a stream from ranges of values Stream s = (Stream)Stream.Funcs.range.run(1, 4); generate Generate a stream with the Funcs Stream s = (Stream)Stream.Funcs.generate.run(0, R.lt.apply(R.placeholder, 3), R.inc); concat Create a stream by concatenating other streams Stream s = (Stream)Stream.Funcs.concat.run(new List{ Stream.of(1), Stream.of(2) }); ","srcFilePath":"src/pages/docs/Methods/funcs.md","id":"funcs","location":"/docs/Methods/funcs.html","url":"/stream-apex/docs/Methods/funcs.html"},"operation":{"title":"Operation Methods","description":"Operation Methods","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} concatOther Concatenate the other streams Stream.of(1) .concatOther(new List{ Stream.with(2, 3) }) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed | Method | Description | | ------ | ----------- | | concatOther(List&lt;Stream&gt;) | Concat list of streams | | concatOther(Stream) | Concat one stream | | concatOther(Stream, Stream) | Concat two streams | | concatOther(Stream, Stream, Stream) | Concat three streams | mapBy Map the Func over the stream elements Stream.with(1, 2, 3) .mapBy(R.inc) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 2 // 3 // 4 // Completed flatMap Map the Func and flatten the stream Stream.with(1, 2, 3) .flatMap(Stream.Funcs.ofData.apply(4)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 4 // 4 // 4 // Completed mapTo Map the element to the value Stream.with(1, 2, 3) .mapTo(4) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 4 // 4 // 4 // Completed filter Filter the stream Stream.with(1, 2, 3) .filter(R.equals.apply(2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 2 // Completed scan Similar to 'reduce', but emit the intermediate results Stream.with(1, 2, 3) .scan(R.add, 0) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 3 // 6 // Completed reduce Reduce over the stream elements Stream.with(1, 2, 3) .reduce(R.add, 0) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 6 // Completed catchError Catch the error and return the recovered value Stream.throwError('error') .catchError(R.constant.apply('success')) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // success // Completed count Get the count of the stream items Stream.with(1, 2, 3) .count() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 3 // Completed | Method | Description | | ------ | ----------- | | count() | Count all | | count(Func) | Count all that matches the predicate | defaultIfEmpty Set the default value if the stream is empty Stream.empty() .defaultIfEmpty(1) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // Completed distinct Get a stream of distinct values, according to the key calculated by the Func Stream.with(1, 2, 3) .distinct(R.mod.apply(R.placeholder, 2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // Completed | Method | Description | | ------ | ----------- | | distinct() | Get a stream of distinct values | | distinct(Func) | Get distinct values based on the compare Func that returns Boolean | distinctUntilChanged Get a stream of values, distinct from the last one Stream.with(1, 2, 1) .distinctUntilChanged(R.equals, R.identity) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 1 // Completed | Method | Description | | ------ | ----------- | | distinctUntilChanged(Func, Func) | Get distinct values based on compare Func and selector Func | | distinctUntilChanged(Func) | Get distinct values based on selector Func | | distinctUntilChanged() | Get distinct values | distinctUntilKeyChanged Get a stream of values, distinct from the last one by key value Stream.with(new Map{ 'name' = 'a' }, new Map{ 'name' = 'a' }) .distinctUntilKeyChanged('name', R.equals) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // {name=a} // Completed | Method | Description | | ------ | ----------- | | distinctUntilKeyChanged(String, Func) | Get distinct values based on key and compare Func | | distinctUntilKeyChanged(String) | Get distinct values based on key | elementAt Get the Nth element, return default value if not found Stream.with(1, 2, 3) .elementAt(3, 4) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 4 // Completed | Method | Description | | ------ | ----------- | | elementAt(Integer, Object) | Get element at the index with default value | | elementAt(Integer) | Get element at the index | every Check if every element matches the predicate Stream.with(1, 2, 3) .every(R.lt.apply(R.placeholder, 4)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // true // Completed join Flatten nested Streams Stream.with(1, Stream.of(2), 3) .join() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // Completed finalize Register a Func that will be called either after completion or error Stream.with(1, 2, 3) .finalize(R.debug.apply(4)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // 4 // Completed find Find the first element that matches the predicate Stream.with(1, 2, 3) .find(R.equals.apply(2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 2 // Completed findIndex Find the index of the first element that matches the predicate Stream.with(1, 2, 3) .findIndex(R.equals.apply(2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // Completed first Find the first element that matches the predicate, otherwise return the default value Stream.with(1, 2, 3) .first(R.equals.apply(4), 4) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 4 // Completed | Method | Description | | ------ | ----------- | | first(Func, Object) | Find the first matching with default value | | first(Func) | Find the first matching | last Find the last element that matches the predicate, otherwise return the default value Stream.with(1, 2, 3) .last(R.equals.apply(4), 4) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 4 // Completed | Method | Description | | ------ | ----------- | | last(Func, Object) | Find the last matching with default value | | last(Func) | Find the last matching | groupBy Group the elements into a map Stream.with(1, 2, 3) .groupBy(R.mod.apply(R.placeholder, 2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // {0=(2), 1=(1, 3)} // Completed ignoreElements Create a stream that ignores all elements Stream.with(1, 2, 3) .ignoreElements() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // Completed isEmpty Check if the stream is empty Stream.with(1, 2, 3) .isEmpty() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // false // Completed max Get the max element according to the comparator Func that returns an Integer Stream.with(1, 2, 3) .max(R.compare) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 3 // Completed | Method | Description | | ------ | ----------- | | max(Func) | Get max value with the comparator Func returning Integer | | max() | Get the max value | min Get the min element according to the comparator Func that returns an Integer Stream.with(1, 2, 3) .min(R.compare) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 3 // Completed | Method | Description | | ------ | ----------- | | min(Func) | Get min value with the comparator Func returning Integer | | min() | Get the min value | onErrorResumeNext Like 'concat', but continue to the next stream only when the first stream has errors Stream.throwError('error') .onErrorResumeNext(new List{ Stream.of('success') }) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // success // Completed pairwise Make pairs from adjacent stream items Stream.with(1, 2, 3) .pairwise() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // Pair:[fst=1, snd=2] // Pair:[fst=2, snd=3] // Completed pluck Pluck the value from the stream elements Stream.with(new Map{ 'name' = 'a' }) .pluck('name') .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // a // Completed repeat Repeat the stream for N times Stream.with(1, 2, 3) .repeat(2) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // 3 // 1 // 2 // 3 // Completed single Get the single element from the stream that matches the predicate Stream.with(1, 2, 3) .single(R.equals.apply(2)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 2 // Completed skip Skip N elements from the stream Stream.with(1, 2, 3) .skip(2) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 3 // Completed skipLast Skip N elements from the last of the stream Stream.with(1, 2, 3) .skipLast(2) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // Completed skipWhile Skip elements while the predicate is true Stream.with(1, 2, 3) .skipWhile(R.lt.apply(R.placeholder, 3)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 3 // Completed take Take the first N elements from the stream Stream.with(1, 2, 3) .take(2) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // Completed takeLast Take the last N elements from the stream Stream.with(1, 2, 3) .takeLast(2) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 2 // 3 // Completed takeWhile Take elements while the predicate is true Stream.with(1, 2, 3) .takeWhile(R.lt.apply(R.placeholder, 3)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 2 // Completed startWith Append the other stream to the stream Stream.with(1, 2, 3) .startWith(Stream.of(0)) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 0 // 1 // 2 // 3 // Completed tap Pass the value through the Func Stream.with(1, 2, 3) .tap(R.debug) .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // 1 // 1 // 2 // 2 // 3 // 3 // Completed toArray Convert the strema elements to a list Stream.with(1, 2, 3) .toArray() .subscribe(R.debug, R.debug.apply('Error: '), R.debug.apply('Completed')); // (1, 2, 3) // Completed ","srcFilePath":"src/pages/docs/Methods/operation.md","id":"operation","location":"/docs/Methods/operation.html","url":"/stream-apex/docs/Methods/operation.html"},"subscription":{"title":"Subscription Methods","description":"Subscription Methods","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} subscribe Subscribe an observer to the stream If the stream is cold, it will emit all the events to this observer If the stream is hot, it will emit events only when they come, to this observer and previous observers Stream.of('abc') .subscribe(new Stream.FuncObserver(R.debug)); // abc | Method | Description | | ------ | ----------- | | subscribe(Observer) | Subscribe an observer | | subscribe(Func, Func, Func) | Subscribe with onNext, onError and onComplete | | subscribe(Func, Func) | Subscribe with onNext, onError | | subscribe(Func) | Subscribe with onNext | ","srcFilePath":"src/pages/docs/Methods/subscription.md","id":"subscription","location":"/docs/Methods/subscription.html","url":"/stream-apex/docs/Methods/subscription.html"}},"title":"Methods","description":"Methods","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} Stream Method Reference Here is the stream method reference. Stream.with(1, 2, 3) .mapBy(R.multiply.apply(2)) .subscribe(R.debug); ","srcFilePath":"src/pages/docs/Methods/index.md","id":"Methods","location":"/docs/Methods/","url":"/stream-apex/docs/Methods/","childIds":["creation","funcs","subscription","operation"]},"Stream":{"title":"Streams","description":"Streams","layout":"guide","icon":"flash","weight":1,"content":" {$page.description} What is a Stream? In a functional reactive world, streams are lists of events over time. But in Apex, with code running in its own execution context, we can hardly build an asynchronous stream. So in Stream.apex, we have only synchronous streams, which are just lists. R.apex has already tons of functions to operate on lists, and then what is the point to build a stream? Well, streams are actully event-driven lists. In R.apex, we do a map on the list, and get a new list. Then we operate on the new list, and continue. In Stream.apex, event-driven lists are different. Streams do not need to create any intermediate lists because they just work in place. When an element in a list is processed, it is treated as an event, and passed through all the operations in the stream chains. This goes on until this single element is fully processed, before the next element gets fired. In this way, streams are modelled like event-driven lists, and each stream receives events and notifies events. Subscription In Stream.apex, streams are just observables that emit events. We have observers that receive these events. Here is how we build an observer with Funcs. Stream.Observer ob = new Stream.FuncObserver(new OnNextFunc(), new OnErrorFunc(), new OnCompleteFunc()); Then we subscribe this observer to the observable. Stream.with(1, 2, 3) .subscribe(ob); The observer may have onNext, onError and onComplete implemented to handle stream events. For simplicity's sake, we can also subscribe using Funcs directly. Stream.with(1, 2, 3) .subscribe(R.debug, R.debug, R.debug); Lazy Stream Streams are lazy in that they only emit values when an observer subscribes them. To check more on lazy streams, please refer to RxJs; Stream Operations Streams are still built in a functional reactive style. We can chain streams using the fluent API like this: Stream.with(1, 2, 3) .startWith(Stream.of(0)) .concatOther(Stream.range(4, 2)) .filter(R.lt.apply(R.placeholder, 4)) .mapBy(R.inc) .subscribe(R.debug); Stream Subjects Stream subjects are hot streams that can multicast events. We can use stream subjects like this: Stream.Subject s = new Stream.Subject(); s.subscribe(R.debug.apply('No.1')); s.subscribe(R.debug.apply('No.2')); s.next(1); s.next(2); // No.1, 1 // No.2, 1 // No.1, 2 // No.2, 2 ","srcFilePath":"src/pages/docs/Stream/index.md","id":"Stream","location":"/docs/Stream/","url":"/stream-apex/docs/Stream/"},"Subject":{"title":"Subject","description":"Subject","layout":"guide","icon":"cloud","weight":4,"content":" {$page.description} Stream Subject Stream subjects can multicast events to multiple observers. Stream.Subject s = new Stream.Subject(); s.subscribe(R.debug.apply('No.1')); s.subscribe(R.debug.apply('No.2')); s.next(1); s.next(2); // No.1, 1 // No.2, 1 // No.1, 2 // No.2, 2 Methods | Method | Description | | ------ | ----------- | | Subject() | Create a default subject | | next(Object) | Send the next event | | error(Object) | Send the error event | | complete() | Send the complete event | ","srcFilePath":"src/pages/docs/Subject/index.md","id":"Subject","location":"/docs/Subject/","url":"/stream-apex/docs/Subject/"}},"childIds":["Stream","Methods","Subject","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/stream-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with Stream.apex","url":"/stream-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Include Apex files","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Mapper.apex has a dependency on R.apex. First, we will include R.apex. Include Func.cls, R.cls, and RTest.cls(optional) into your Org, and R.apex is ready. Then, we will include Stream.apex. Include Stream.cls, and StreamTest.cls(optional) into your Org, and you are ready to go. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/stream-apex/tutorials/getting_started/step_1.html"},"step_2":{"title":"Preliminary Knowledge","description":"Preliminary Knowledge","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} It's recommended that you have a fair amount of knowledge on R.apex, but it's not required. Stream.apex uses Func objects from R.apex, and a Func is actually a custom Apex object that mimics the behavior of a function. Here is how your implement a custom Func. public class HelloWorldFunc extends Func { public HelloWorldFunc() { super(0); // specify the number of arguments the Func takes } // Provide custom implementation for a Func that takes 0 arguments. public override Object exec() { return 'Hello World'; } } And then you instantiate, and invoke it. Func helloworld = new HelloWorldFunc(); String msg = (String)helloworld.run(); To get deeper with Func objects, please check R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/stream-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"Create Streams","description":"Create Streams","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} We have various ways to create streams in Stream.apex. Stream.of(1); // Create a stream with element 1 Stream.with(1, 2, 3); // Create a stream with elements 1, 2, 3 Stream.fromData(new List{ 1, 2, 3}); // Create a stream with a list of elements Stream.range(1, 3); // Create a stream that start at 1 and creates 3 numbers Stream.empty(); // Create an empty stream Stream.throwError('error'); // Create a stream that throws error ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/stream-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Subscription","description":"Subscription","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} After streams are created, you can subscribe them to receive emitted events. Stream.with(1, 2, 3) .subscribe(R.debug, R.debug.apply('Error'), R.debug.apply('Completed')); Here we subscribed the stream with three callback Funcs, onNext, onError and onComplete. When streams are emitting events, we can received these events from onNext. When streams complete their work, they will call onComplete at last. When an error is met, streams will call onError to notify. These three functions actuall consist of the observer object, and streams are just observables. ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/stream-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Lazy Streams","description":"Lazy Streams","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} Streams are lazy and will not emit events until you actually subscribe them. Stream.with(1, 2, 3) // Will not emit events .subscribe(R.debug); // Will emit events This kind of streams have the data within them, and when one observer subscribes them, they will emit data to this observer, including all the events. When a new observer subscribes, the same data will be emitted. Hence streams are just like working only for these subscribed observers alone. They unicast events to observers and are called cold streams. ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/stream-apex/tutorials/getting_started/step_5.html"},"step_6":{"title":"Stream Operations","description":"Stream Operations","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} We have operations for streams that can be chained easily to build our logic. Stream.with(1, 2, 3) .mapBy(R.inc) .startWith(Stream.of(1)) .subscribe(R.debug); // 1, 2, 3, 4 Here we created a stream with 1, 2, 3 and incremented each element with 1. Besides, we prepended a new stream of 1 to the stream. So finally we got 1, 2, 3, 4. Each stream operation will create a new stream, and these streams are subscribed in a chain, so that the events from the top of the chain can flow to the bottom, calling each operation. That means, the list of elements are not processed as a whole from one operation to another. Instead, each element of the list gets processed from one operation to another. The next element will not start processing until the previous element is finished. They are driven by events and therefore are called reactive. ","srcFilePath":"src/pages/tutorials/getting_started/step_6.md","id":"step_6","location":"/tutorials/getting_started/step_6.html","url":"/stream-apex/tutorials/getting_started/step_6.html"},"step_7":{"title":"Subjects","description":"Subjects","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} Subjects are actually another kind of streams, hot streams. They work quite similar to lazy streams, except that they do not maintain the events inside them. To be more clearly, subjects receive events and then emit them to all the registered observers. When one observer subscribes the subject, the subject will not emit the previously emittd events to the new observer. It will only emit the events fired after the observer subscribed. Subjects can multicast events to observers, and they are called hot streams. Stream.Subject s = new Stream.Subject(); s.subscribe(R.debug.apply('No.1')); s.subscribe(R.debug.apply('No.2')); s.next(1); s.next(2); // No.1, 1 // No.2, 1 // No.1, 2 // No.2, 2 ","srcFilePath":"src/pages/tutorials/getting_started/step_7.md","id":"step_7","location":"/tutorials/getting_started/step_7.html","url":"/stream-apex/tutorials/getting_started/step_7.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5","step_6","step_7"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/stream-apex"}